
---
# Introducción. IP, TCP y UDP

[Back to index](../README.md)

---
## Protocolo IP
### Definición
- Enruta paquetes por nodos intermedios para llegar a nodo final
- **Maximum Transfer Unit - MTU**
	- Max. 64 kB pero cada red puede limitarlo más.
	- Paquetes grandes son fragmentados o descartados
- Protocolo no confiable. Paquetes pueden perderse.
### Direcciones IP
- Formato
	- **IPv4**. 32b o 4 octetos ($4\times8b = 32b$)
	- **IPv6**. 128b o 8 hexetos ($8\times16b = 128b$)
- **Rangos**
	- **Privadas**.
		- `192.168.0.0/16`
		- `172.16.0.0/12`
		- `10.0.0.0/8
	- **Locales**. `127.0.0.0/8`
	- **Broadcast**. `0.0.0.0/8`
	- **Multicast**. `224.0.0.0/4`
### Header
- **Word 1 ($32b = 4B$)**
	- `Version (4b)`. En este caso 4
	- `Header Length - HLen (4b)`.
		- Medido en words desde 5 ($5\times4B = 20B$) hasta 15 ($15\times4B = 60B$)
	- `Type of Service - ToS (8b)`
	- `Total Length (16b)`
		- Header + data. Medido en bytes
		- $2^{16} B \to 2^6 KiB \to 64 KiB$
- **Word 2**
	- `Identification (16b)`. ID para grupo de fragmentos
	- `Flags (3b)`. Null + Don't Fragment + More fragments
	- `Fragment Offset (13b)`. Identifica fragmento en mismo grupo
- **Word 3**
	- `Time To Live - TTL (8b)`
	- `Protocol (8b)`. Protocolo capa de transporte
	- `Checksum (16b)`. Comprueba errores.
- **Word 4. `IP origen`**
- **Word 5. `IP destino`**
- **Words 6-15. `Options`**
---
## Nivel de Transporte. UDP
### Problemas y soluciones
- ¿Quién inicia la comunicación?
	- Protocolo de turnos que indique quien comienza (`sendto()`)
- ¿Cómo conoce la IP y puerto?
	- Configuración manual (consola), por DHCP o descubrimiento por broadcast
- ¿Qué números de puerto son válidos?
	- Estandarización (ver debajo)
- ¿Como identificar datagramas perdidos?
	- Envío de ACKs, numeración datagramas, timeouts y reenvíos.
- ¿Qué pasa si un datagrama no cabe en el MTU?
	- Fragmentación. Si cualquier "trozo" se pierde, se invalida todo el datagrama.
### Broadcast
- Recibido por todos los nodos en mismo segmento de red.
- Para recibirlo. Socket en modo broadcast `setsockopt()`.
- Para enviarlo. Encontrar IP broadcast en segmento.
---
## Nivel de Transporte. TCP
### Ventajas
- Incluye ACKs, checksums y numeración
- Control de flujo con ventana deslizante
- Autodetección de congestión
### *Framing*
#### Problema
- Funcionamiento de `recv()`
	- Puede devolver menos datos de los enviados.
	- Se puede tener que invocar varias veces.
	- Si se invoca y no hay mas datos el receptor se bloquea.
#### Soluciones
- **Cerrar el socket tras ultimo byte**
	- `recv()` retorna 0 bytes. Entonces cerramos socket.
- **Mensajes de tamaño prefijado**
- **Usar un byte terminador (`\n` o `\0`)**
	- El byte no puede aparecer en el mensaje.
	- Si aparece usamos códigos de escape.
- **Longitud especificada**
	- Se envía la solicitud antes del mensaje
	- Tamaño fijo para longitud (`4B`)
	- El emisor debe conocer la longitud de antemano
- **Mensaje en trozos con longitud**
	- Se envían varios "trozos", cada uno de ellos precedido por su longitud.
	- El último trozo es un bloque de longitud 0. Indica la terminación.
#### Ejemplos
- **Técnicas Hibridas**
	- HTTP usa terminador para header (`\r\n\r\n`) y longitud para cuerpo (`ContentLength`)
- **Tipos de datos estructurados**
	- Representación deja claro donde termina (`XML`, `JSON`)
### Concurrencia
- Creación de procesos servidores (`fork()`)
- Creación de hilos trabajadores (*threads*)
- Uso de multiplexación (`select()`, `poll()`)
	- Única opción si hay muchos clientes.
	- Lógica de programa se complica.
---
## Nivel de Transporte. Estandarización de puertos
- Puertos bien conocidos: 0 - 1023 (ver tabla)
- Puertos registrados: 1204 - 49151
- Puertos libres: 49152 - 65535

| Puerto  | Protocolo  |
| ------- | ---------- |
| 7       | Echo       |
| 20      | FTP (data) |
| 21      | FTP (Ctrl) |
| 22      | SSH        |
| 23      | Telnet     |
| 25      | SMTP       |
| 53      | DNS        |
| 67 - 68 | DHCP       |
| 80      | HTTP       |
| 110     | POP3       |
| 443     | HTTPS      |

---
