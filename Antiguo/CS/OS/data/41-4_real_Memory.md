
---
# Real memory management mechanisms

[Back to index](../README.md)

---
## Introduction
### Ways to Manage Memory
- **Real memory**
	- Whole process is loaded to MM.
	- Low multiprogramming.
	- Can be contiguous allocated or not.
- **Virtual memory**
	- Processes are partially loaded to MM.
	- Higher multiprogramming.
	- Uses secondary memory as backup.
### Historical Evolution
1. Real memory
	1. Contiguous Allocation
		1. Single-process monitor (OS + transient)
		2. Multi-programmed systems (1 process - 1 partition)
			1. With fixed partitions
			2. With dynamic partitions
	2. Non-contiguous allocation
		1. Simple paging
		2. Simple segmentation
		3. Paged segmentation
2. Virtual memory
	1. Paging on-demand
	2. Segmentation on-demand
	3. Paged segmentation.

---
## Contiguous memory allocation
### Singe-process monitor (OS)
#### Physical organization of the MM
- OS present at lower positions
- The only process is stored before the OS in the transient area.
- Processes life cycle: One stops -> It is removed -> Load another.
#### Protection
- Base register contains the initial physical address of the process in MM.
- Limit register contains the process size (in bytes).
- Process cannot access any logical address greater than the limit register.
- Every address generated by the CPU is checked.
#### Translation Steps (Dynamic translation)
1. We have a logical address generated by the CPU.
2. Protection:  $\text{Logical address} > \text{Limit register} \implies \text{Exception}$
3. Translation: $\text{Logical address} + \text{Base register} = \text{Physical Address}$
4. We have a physical address to access the MM.

### Multi-processing with fixed partitions
#### Physical organization of the MM
- MM is divided into pieces called partitions.
	- Partitions have a fixed size but not necessarily the same.
- The partition 0 is assigned to the OS.
- Each process is inside a partition that is bigger that them.
	- There is a waste of MM called internal fragmentation.
- If no partition is free processes must wait (suspended) or replace another one.
#### Data Structure
- A partition table is required.
	- State (free/used), Partition base, Partition size.
- A queue for processes to access the MM is required.
	- Can have one single input queue or one per petition.
#### Assignment Strategies
(One partition, one process. Only partition bigger than the process are electable)
- **First-fit** (First available partition starting from the first one)
- **Next-fit** (First available partition starting from the last assigned one)
- **Best-fit** (Available partition with less free space)

#### Protection & Translation Steps
- Same as in single-process monitor.

### Multi-processing with dynamic partitions
#### Organization of the MM
- MM is divided into partitions and free spaces called hollows
- Initially there is only the OS partition and a big hollow.
- Each process:
	- Creates a new partition as big as the process.
	- Starts at the first available and big enough hollow.
	- Partition is erased on process finishing.
- Note that partitions cannot move as they hold a running process.
- It suffers from external fragmentation.
	- Is the wasted space of the small hollows in between partitions.
	- Hollow condensation: Join adjacent hollows into one single hollow.
	- Compaction: Move process to have always only one big hollow.
#### Data Structures
- A list of partitions and hollows is required (Can be joined os separated).
- For each hollow we have a initial physical address and its size in bytes.
- For the partitions we also have the PID.
#### Assignment Strategies, Protection & Translation Steps
- Same as in multi-processing with fixed partitions.

---
## Non-contiguous memory allocation
### Simple paging
#### Organization of the MM
- MM is divided into equal size pieces called frames.
- $\text{\# frames} \times \text{frame size} = \text{memory size}$
- Processes can be occupy several non-adjacent frames.
- We need a process page to store the occupied frames.
- $\text{\# pages} = \text{\# processes}$
- This process page can be stored in any frame.
	- We need a Page Table Base Register (PTBR)
#### Data Structures
- **Frame table**
	- Only one for whole system.
	- Has an entry for each frame (assigned/free, page number, PID)
	- Free frames can be stored in a list for efficiency.
- **Pages table**
	- One per process.
	- Has an entry per occupied frame by the process.
	- Stores: page number (table index),  frame number and protection bits.
#### Translation of Addresses
- Logical addresses ( $L$ ) are divided into:
	- Page number bits ( $p$ ).  Where $2^{\:p}$ is the max. number of pages.
	- Sift bits ( $s$ ). Where $2^{\:s}$ is the pages size.
- Physical addresses ( $P$ ) are divided into:
	- Frame number bits ( $f$ ).  Where $2^{\:f}$ is the total number of frames.
	- Sift bits ( $s$ ). Where $2^{\:s}$ is the frames size.

(Note that the sift bits are equal for both logical and physical addresses)
#### Protection
- Check with limit register done during the address translation.
- Protection bits are also used.

### Simple segmentation
#### Organization of the MM
- Processes split into segments variable in size  (code, data, stack).
- Segments reside in contiguous MM locations.
- Initially MM is divided into OS segments and a big hollow.
- Similar to dynamic partitions but $1 \text{process} \neq 1 \text{segment}$.
#### Data Structures
- **Hollow list**
- **Segments table**
	- One table per process.
	- One entry per segment in the process.
	- In each entry: Base address, segment limit/length and protection bits.
	- It is stored in memory. We need a Segment Table Base Register (STBR)
### Paged Segmentation
- Combination of simple paging and segmentation.
- MM divided into same size blocks called frames.
- Steps:
	1. Split process into segments (code, data, stack).
	2. Consider each segment a page and locate it in a frame.

---